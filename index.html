<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>Playing</title>
		<style>
			body {
				background-color: #363;
				background-image: url('https://i.ibb.co/9Zvz58h/star.png')
			}
			#video {
				display: none;
			}
			#snapshot {
				width: 100%;
			}
		</style>
	</head>
	<body>
		before
		afterwards
		there
		is
		always
		something
		around
		you

			<p><button id="start">Screenshot!</button>

			<video id="video" autoplay></video>
			<img id="snapshot" src="">
	</body>

	<script>
		const red = 0;
		const green = 1;
		const blue = 2;
		const alpha = 3;
		const videoElem = document.getElementById("video");
		const imageElem = document.getElementById("snapshot");
		const startElem = document.getElementById("start");

		const canvas = document.createElement("canvas");
		const context = canvas.getContext('2d');

		var displayMediaOptions = {
		video: {
			cursor: "none"
			},
			audio: false
		};

		// Set event listeners for the start and stop buttons
		startElem.addEventListener("click", function(evt) {
			console.log("start");
			startCapture();
		}, false);

		videoElem.addEventListener('play', function(evt) {
			console.log("play");
			setup();
		}, false);

		function setup() {
			console.log("setup");
			const width = videoElem.videoWidth;
			const height = videoElem.videoWidth;
			canvas.width = width;
			canvas.height = height;

			context.drawImage(video, 0, 0);
			stopCapture();

			const imageData = context.getImageData(0, 0, width, height);
			const pixels = imageData.data;
			const background_composite = getBackgroundRGB(pixels, width, height);

			animate(background_composite, width, height);
		}

		function getBackgroundRGB(pixels, width, height) {
			console.log("rgb");
			let rgb_use = new Array(0x1000000).fill(0);

			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const index = ((y * width) + x) * 4;

					const rgb = rgb_to_composite(
						pixels[index + red],
						pixels[index + green],
						pixels[index + blue]);

					rgb_use[rgb]++;
				}
			}

			let max_index = 0;
			for (let rgb = 0; rgb < rgb_use.length; rgb++) {
				if (rgb_use[max_index] < rgb_use[rgb])
					max_index = rgb;
			}

			console.log(
				'rgb ' + max_index +
				' as ' + composite_to_rgb(max_index) +
				' used ' + rgb_use[max_index])
			return max_index;
		}

		function rgb_to_composite(r, g, b) {
			return ((r & 0x0ff) << 16) | ((g & 0x0ff ) << 8) | (b & 0x0ff);
		}

		function composite_to_rgb(composite) {
			const r = (composite >> 16) & 0x0ff;
			const g = (composite >> 8) & 0x0ff;
			const b = (composite) & 0x0ff;

			return [r, g, b];
		}

		function render(frame, background_composite, width, height) {
			//console.log("render");
			const imageData = context.getImageData(0, 0, width, height);
			const pixels = imageData.data;
			const background_rgb = composite_to_rgb(background_composite);

			for (let y = height-2; y >= 0; y--) {
				for (let x = 0; x < width; x++) {
					const index = ((y * width) + x) * 4;
					const below = (((1+y) * width) + x) * 4;

					// what moves
					if (!(pixels[index + red] != background_rgb[red] &&
							pixels[index + green] != background_rgb[green] &&
							pixels[index + blue] != background_rgb[blue]))
						continue;


					// what blocks
					if ((pixels[below + red] != background_rgb[red] &&
							pixels[below + green] != background_rgb[green] &&
							pixels[below + blue] != background_rgb[blue]))
						continue;

					// swap whats below with pixel, this will cause
					// corruption as the pixel below "floats" up due
					// to multiple swaps.
					// TODO: use a secondary background for swap (with moving px removed)
					for (let part = 0; part < alpha; part++) {
						temp = pixels[index + part];
						pixels[index + part] = pixels[below + part];
						//pixels[index + part] = background_rgb[part];
						pixels[below + part] = temp;
					}
				}
			}

			context.putImageData(imageData, 0, 0);
			if (frames % 10 == 0) {
				imageElem.src = canvas.toDataURL("image/png");
			}
		}

		var frames = 0;
		function animate(background_rgb, width, height) {
			render(frames++, background_rgb, width, height);

			// animation loop
			window.requestAnimationFrame(() => animate(background_rgb, width, height));
		}

		async function startCapture() {
			console.log("starting capture");

			try {
				videoElem.srcObject = await navigator.mediaDevices
					.getDisplayMedia(displayMediaOptions);
			} catch(err) {
				console.error("Error: " + err);
			}
		}

		function stopCapture(evt) {
			if (!videoElem.srcObject) {
				return;
			}

			let tracks = videoElem.srcObject.getTracks();

			tracks.forEach(track => track.stop());
			videoElem.srcObject = null;
		}
	</script>
</html>

